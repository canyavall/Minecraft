# Grid-Based Structure Placement - Visual Explanation

## Example 1: Villages with Spacing=32 (Vanilla)

### Grid Layout

Each structure type divides the world into a grid based on its SPACING parameter.

For villages with spacing=32 chunks:

```
     0        32       64       96      128      160      192      224      256
     ├────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤ (z-axis)
0    ┌────────┬────────┬────────┬────────┬────────┬────────┬────────┬────────┐
     │        │        │        │        │        │        │        │        │
     │  (0,0) │  (1,0) │  (2,0) │  (3,0) │  (4,0) │  (5,0) │  (6,0) │  (7,0) │
32   ├────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤
     │        │        │        │        │        │        │        │        │
     │  (0,1) │  (1,1) │  (2,1) │  (3,1) │  (4,1) │  (5,1) │  (6,1) │  (7,1) │
64   ├────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤
     │        │        │        │        │        │        │        │        │
     │  (0,2) │  (1,2) │  (2,2) │  (3,2) │  (4,2) │  (5,2) │  (6,2) │  (7,2) │
96   ├────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤
     │        │        │        │        │        │        │        │        │
     │  (0,3) │  (1,3) │  (2,3) │  (3,3) │  (4,3) │  (5,3) │  (6,3) │  (7,3) │
128  └────────┴────────┴────────┴────────┴────────┴────────┴────────┴────────┘
(x-axis)
```

Each cell = 32×32 chunks = 1024 chunks per cell

### Salt-Based Candidate Selection

Within each grid cell, ONE random chunk is selected as the candidate.

Example: Village salt = 10387312, World seed = 1234567890

```
Cell (3, 6):  Boundaries: chunks (96, 192) to (127, 223)

    192                                 223 (z-axis)
     ├──────────────────────────────────┤
 96  ┌──────────────────────────────────┐
     │                                  │
     │   32×32 chunk grid cell          │
     │                                  │
     │         ┌─────────────────┐      │
     │         │  Random offset  │      │
     │         │  based on SALT  │      │
     │         │  + world seed   │      │
     │         └─────────────────┘      │
     │                                  │
     │                     ●            │  ← Candidate chunk (110, 214)
     │                   (110, 214)     │     This is the ONLY chunk in cell (3,6)
     │                                  │     where villages will attempt placement
     │                                  │
     │    ◯            ◯           ◯    │  ← Other chunks in cell (NOT candidates)
     │  (100,200)   (105,205)   (120,210)   Villages SKIP these chunks
     │                                  │
127  └──────────────────────────────────┘
```

Calculation for cell (3, 6):
```
Step 1: Generate salt-based seed
  seed = worldSeed + cellX*341873128712 + cellZ*132897987541 + villageSalt
       = 1234567890 + 3*341873128712 + 6*132897987541 + 10387312
       = 1823017172592

Step 2: Create Random instance
  random = new Random(1823017172592)

Step 3: Calculate offset within cell
  separation = 8 (minimum distance)
  maxOffset = spacing - separation = 32 - 8 = 24

  offsetX = random.nextInt(24) = 14  (deterministic based on seed!)
  offsetZ = random.nextInt(24) = 22

Step 4: Calculate candidate chunk
  candidateX = cellX * spacing + offsetX = 3 * 32 + 14 = 110
  candidateZ = cellZ * spacing + offsetZ = 6 * 32 + 22 = 214

  Candidate chunk: (110, 214) ✓
```

### Chunk-by-Chunk Evaluation

For each chunk being generated, Minecraft checks: "Is this chunk the candidate?"

Example chunks in cell (3, 6):

```
Chunk (100, 200):
  cellX = floor(100/32) = 3
  cellZ = floor(200/32) = 6
  candidate = calculateCandidate(3, 6, salt, seed) = (110, 214)
  Does (100, 200) == (110, 214)? NO
  Result: SKIP villages ✗

Chunk (110, 214):
  cellX = floor(110/32) = 3
  cellZ = floor(214/32) = 6
  candidate = calculateCandidate(3, 6, salt, seed) = (110, 214)
  Does (110, 214) == (110, 214)? YES
  Result: ATTEMPT village placement ✓

Chunk (115, 220):
  cellX = floor(115/32) = 3
  cellZ = floor(220/32) = 6
  candidate = calculateCandidate(3, 6, salt, seed) = (110, 214)
  Does (115, 220) == (110, 214)? NO
  Result: SKIP villages ✗
```

**Key Insight**: Out of 1024 chunks in cell (3, 6), only ONE chunk (110, 214) will attempt village placement!


## Example 2: Multiple Structure Types in Same Chunk

Different structure types have different SALTS, creating independent grid patterns.

Chunk (100, 200) - Plains biome:

```
Structure: Villages (spacing=32, salt=10387312)
  Cell: (3, 6)
  Candidate: (110, 214)
  Result: SKIP (100, 200) ≠ (110, 214) ✗

Structure: Pillager Outposts (spacing=32, salt=165745296)
  Cell: (3, 6)  [Same cell, DIFFERENT salt!]
  Candidate: (105, 202)  [Different offset due to different salt]
  Result: SKIP (100, 200) ≠ (105, 202) ✗

Structure: Ruined Portals (spacing=25, salt=34222645)
  Cell: (4, 8)  [Different cell size: 25×25 chunks]
  Candidate: (100, 200)  [Matches by chance!]
  Result: ATTEMPT placement ✓

Structure: Desert Temples (spacing=32, salt=14357617)
  Cell: (3, 6)
  Candidate: (98, 195)
  Result: SKIP (100, 200) ≠ (98, 195) ✗

Structure: Dungeons (spacing=8, salt=0)
  Cell: (12, 25)  [Small cells: 8×8 chunks]
  Candidate: (100, 200)  [Matches!]
  Result: ATTEMPT placement ✓
  But: SKIP (wrong biome - dungeons underground) ✗
```

Visual representation:

```
     Chunk (100, 200) - Plains biome

     ┌─────────────────────────────┐
     │                             │
     │     Ruined Portal ✓         │  ← Matches grid, compatible biome
     │                             │     WILL ATTEMPT placement
     │                             │
     │     Villages ✗              │  ← Not grid candidate
     │     Outposts ✗              │  ← Not grid candidate
     │     Desert Temples ✗        │  ← Not grid candidate
     │     Dungeons (✓) → ✗        │  ← Matches grid but wrong biome
     │                             │
     └─────────────────────────────┘
```

Result: Only 1 structure attempts placement at chunk (100, 200) out of 80-150 possible structures.


## Example 3: Impact of Spacing Multiplier (Our Mod)

### Before: Spacing=32 (Vanilla)

```
Grid cells: 32×32 chunks = 1024 chunks per cell

    0        32       64       96      128      160      192      224
    ├────────┼────────┼────────┼────────┼────────┼────────┼────────┤
0   ┌────────┬────────┬────────┬────────┬────────┬────────┬────────┐
    │        │        │        │        │        │        │        │
    │   ●    │    ●   │   ●    │   ●    │    ●   │    ●   │   ●    │  ← Many candidates
32  ├────────┼────────┼────────┼────────┼────────┼────────┼────────┤
    │        │        │        │        │        │        │        │
    │    ●   │   ●    │    ●   │    ●   │   ●    │   ●    │    ●   │
64  ├────────┼────────┼────────┼────────┼────────┼────────┼────────┤
    │        │        │        │        │        │        │        │
    │   ●    │    ●   │   ●    │   ●    │    ●   │    ●   │   ●    │
96  └────────┴────────┴────────┴────────┴────────┴────────┴────────┘

Probability of any chunk being candidate: 1/1024 ≈ 0.1%
With 80-150 structure sets: ~8-15 candidates per chunk
```

### After: Spacing=64 (2.0x Multiplier)

```
Grid cells: 64×64 chunks = 4096 chunks per cell

    0                64              128              192              256
    ├────────────────┼────────────────┼────────────────┼────────────────┤
0   ┌────────────────┬────────────────┬────────────────┬────────────────┐
    │                │                │                │                │
    │                │                │                │                │
    │       ●        │       ●        │       ●        │       ●        │  ← Fewer candidates
    │                │                │                │                │
    │                │                │                │                │
64  ├────────────────┼────────────────┼────────────────┼────────────────┤
    │                │                │                │                │
    │                │                │                │                │
    │       ●        │       ●        │       ●        │       ●        │
    │                │                │                │                │
    │                │                │                │                │
128 ├────────────────┼────────────────┼────────────────┼────────────────┤
    │                │                │                │                │
    │                │                │                │                │
    │       ●        │       ●        │       ●        │       ●        │
    │                │                │                │                │
    │                │                │                │                │
192 └────────────────┴────────────────┴────────────────┴────────────────┘

Probability of any chunk being candidate: 1/4096 ≈ 0.025%
With 80-150 structure sets: ~2-4 candidates per chunk
```

### Performance Impact

```
Vanilla (spacing=32):
  Per chunk: ~8-15 grid matches
  → ~8-15 biome checks
  → ~4-8 generation attempts
  → ~2-4 successful placements
  Time: ~20ms per chunk

With 2.0x multiplier (spacing=64):
  Per chunk: ~2-4 grid matches (50% reduction!)
  → ~2-4 biome checks
  → ~1-2 generation attempts
  → ~1-2 successful placements
  Time: ~10ms per chunk (50% faster!)

Result: Fewer structures checked = Faster worldgen ✓
```


## Example 4: Why 569 Structures ≠ 569 Checks Per Chunk

### Common Misconception

"With 569 structures, Minecraft checks 569 structures per chunk"

**FALSE!**

### Actual Filtering Process

```
569 Structures Globally
    ↓
[Dimension Filter]
    ↓
400 Structures (Overworld-compatible)
    ↓
[Biome Source Filter]
    ↓
80-150 Structure Sets (biome-compatible with this world)
    ↓
[Grid Check - PER CHUNK]
    ↓
5-20 Grid Matches (candidate chunks)
    ↓
[Biome Check - PER CHUNK]
    ↓
2-10 Biome-Compatible (valid for this chunk's biome)
    ↓
[Generation + Validation]
    ↓
1-3 Successfully Placed
```

### Breakdown for Chunk (100, 200) - Plains Biome

```
Starting with 569 structures:

Step 1: Dimension filter
  569 structures → 400 Overworld structures
  Filtered out: Nether fortresses, End cities, Bastion remnants
  Remaining: 400 structures ✓

Step 2: Biome source filter (at world load)
  400 structures → 120 structure sets (example for diverse biome world)
  Filtered out: Structures requiring biomes not in this world
  Example: If world has no mushroom biomes, mushroom structures filtered
  Remaining: 120 structure sets ✓

Step 3: Grid check (at chunk generation)
  120 structure sets → Check each with shouldGenerate(100, 200)

  Results:
    Village (32): Cell (3,6), candidate (110, 214) → NO ✗
    Outpost (32): Cell (3,6), candidate (105, 202) → NO ✗
    Desert Temple (32): Cell (3,6), candidate (98, 195) → NO ✗
    Ruined Portal (25): Cell (4,8), candidate (100, 200) → YES ✓
    Mineshaft (spacing varies): Cell varies, some YES, some NO
    ... (check all 120) ...

  Grid matches: 8 structures ✓

Step 4: Biome check (for 8 grid matches)
  Chunk biome: Plains

  Results:
    Ruined Portal: Can spawn in plains → YES ✓
    Desert Well: Cannot spawn in plains → NO ✗
    Ice Spike: Cannot spawn in plains → NO ✗
    Plains Village: Can spawn in plains → YES ✓
    Ocean Monument: Cannot spawn in plains → NO ✗
    ... (check all 8) ...

  Biome-compatible: 3 structures ✓

Step 5: Generation + validation (for 3 biome-compatible)
  Results:
    Ruined Portal: Generated successfully ✓
    Plains Village: Terrain validation failed (too hilly) ✗
    Dungeon: Generated successfully ✓

  Successfully placed: 2 structures ✓
```

**Summary**: Started with 569, but only 2 actually placed!

**Key Takeaway**: Grid check is the PRIMARY filter that reduces 120 structure sets down to 8 checks.


## Example 5: Salt Distribution Ensures Even Spread

### Why Use Salt?

Without salt, ALL structures would have candidates in the SAME chunks!

```
Bad (no salt):
  Village candidate for cell (3,6): chunk (110, 214)
  Outpost candidate for cell (3,6): chunk (110, 214)  [SAME!]
  Temple candidate for cell (3,6): chunk (110, 214)   [SAME!]

  Result: All structures cluster in same chunks → Bad distribution
```

With different salts:

```
Good (unique salts):
  Village (salt=10387312): Cell (3,6) → candidate (110, 214)
  Outpost (salt=165745296): Cell (3,6) → candidate (105, 202)  [DIFFERENT]
  Temple (salt=14357617): Cell (3,6) → candidate (98, 195)    [DIFFERENT]

  Result: Structures spread across different chunks ✓
```

### Visual: Cell (3,6) with Multiple Structure Types

```
    192                                 223 (z-axis)
     ├──────────────────────────────────┤
 96  ┌──────────────────────────────────┐
     │                                  │
     │    Desert Temple ●               │  (98, 195)
     │                                  │
     │                                  │
     │              Outpost ●           │  (105, 202)
     │                                  │
     │                                  │
     │                     Village ●    │  (110, 214)
     │                                  │
     │                                  │
127  └──────────────────────────────────┘

Each structure type has its own candidate chunk due to unique salt!
```


## Example 6: Separation Parameter

SEPARATION defines minimum distance between structure attempts.

```
spacing = 32 chunks
separation = 8 chunks

Grid cell size: 32×32 chunks
Valid offset range: 0 to (32-8) = 0 to 24 chunks

    ┌────────────────────────────────┐
    │                                │  32 chunks
    │   ┌────────────────────┐       │
    │   │                    │       │
    │   │  Valid candidate   │       │  24×24 chunks
    │   │  region (24×24)    │       │  (can place anywhere in here)
    │   │                    │       │
    │   └────────────────────┘       │
    │         8 chunk buffer         │  Ensures structures stay
    │         (separation)           │  at least 8 chunks from
    │                                │  cell boundaries
    └────────────────────────────────┘
```

**Why Separation Matters**:
- Prevents structures from spawning too close to cell boundaries
- Ensures minimum distance between structures in adjacent cells
- separation=8 with spacing=32 means structures are AT LEAST 8 chunks apart

**Example**:
```
Cell (3,6): Village candidate at (110, 214)
Cell (4,6): Village candidate at (128+offset, 214+offset)
            where offset ≥ 0 (due to separation)

Minimum possible candidate in cell (4,6): (128+0, 192+0) = (128, 192)

Distance between cells: (128, 192) - (110, 214) = 18 chunks minimum
```

**Our Multiplier's Impact**:
```
Original:  spacing=32, separation=8  → offset range: 0-24
Modified:  spacing=64, separation=16 → offset range: 0-48

Larger offset range = More randomness within cell
Structures still stay at least 16 chunks from boundaries
```


═══════════════════════════════════════════════════════════════════════════════
                                  SUMMARY
═══════════════════════════════════════════════════════════════════════════════

Grid-Based Placement Key Points:

1. World divided into grid cells (size = spacing parameter)
2. Each structure type has unique SALT → unique grid pattern
3. One candidate chunk per cell (deterministic based on seed + salt)
4. Chunk checks: "Am I the candidate?" (very fast: O(1))
5. Only candidates attempt placement → Massive filtering effect
6. 569 structures → 80-150 filtered → 5-20 grid matches → 1-3 placed

Performance Optimization:

1. Larger spacing = Larger cells = Fewer candidates per area
2. 2x spacing multiplier = 4x larger cells = ~50% fewer checks
3. Grid check is cheap, but generation is expensive
4. Reducing grid matches = Reducing expensive generation attempts
5. Our mod: Increase spacing → Fewer matches → Better performance ✓

═══════════════════════════════════════════════════════════════════════════════
